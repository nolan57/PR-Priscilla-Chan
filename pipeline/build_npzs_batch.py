#!/usr/bin/env python3
"""
Batch build DiffSinger training .npz dataset (supports external high-precision F0)
[Enhanced version] Supports recursive processing of directory structures while maintaining output directory consistency

Input:
- Dry vocal WAV file directory (44.1kHz)
- Corresponding TextGrid directory (containing "phones" tier)
- (Optional) External F0 file directory (generated by extract_perfect_f0.py, format: *.f0.npy)

Output:
- Standard DiffSinger .npz files, maintaining consistency with input directory structure
"""

import os
import argparse
from pathlib import Path

# Import the single file processing function from build_npzs
from build_npzs import build_single_npz

def process_directory(wav_dir, textgrid_dir, output_dir, f0_dir=None, use_external_f0=True, speaker_id=0):
    """
    Recursively process WAV files in directory structure, maintaining output directory consistency.
    """
    wav_dir = os.path.abspath(wav_dir)
    textgrid_dir = os.path.abspath(textgrid_dir)
    output_dir = os.path.abspath(output_dir)
    f0_dir = os.path.abspath(f0_dir) if f0_dir else None
    
    # Validate if input directories exist
    if not os.path.exists(wav_dir):
        print(f"Error: WAV directory '{wav_dir}' does not exist")
        return 0
    
    if not os.path.exists(textgrid_dir):
        print(f"Error: TextGrid directory '{textgrid_dir}' does not exist")
        return 0
    
    if f0_dir and not os.path.exists(f0_dir):
        print(f"Error: F0 directory '{f0_dir}' does not exist")
        return 0
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    total_files = 0
    processed_files = 0
    skipped_files = 0
    
    # Recursively traverse WAV directory
    for root, _, files in os.walk(wav_dir):
        # Filter WAV files
        wav_files = [f for f in files if f.lower().endswith('.wav')]
        total_files += len(wav_files)
        
        for wav_file in wav_files:
            # Complete WAV file path
            wav_path = os.path.join(root, wav_file)
            
            # Calculate relative path
            rel_path = os.path.relpath(wav_path, wav_dir)
            
            # Extract directory part
            rel_dir = os.path.dirname(rel_path)
            
            # Extract filename (without extension)
            base_name = os.path.splitext(wav_file)[0]
            
            # Build corresponding TextGrid path
            tg_filename = f"{base_name}.TextGrid"
            tg_path = os.path.join(textgrid_dir, rel_dir, tg_filename)
            
            # Check if TextGrid file exists
            if not os.path.exists(tg_path):
                print(f"❌ Skipping {rel_path}: Corresponding TextGrid file not found")
                skipped_files += 1
                continue
            
            # Build F0 directory path (if external F0 is enabled)
            current_f0_dir = None
            if use_external_f0 and f0_dir:
                f0_subdir = os.path.join(f0_dir, rel_dir)
                if os.path.exists(f0_subdir):
                    current_f0_dir = f0_subdir
                else:
                    print(f"⚠️  F0 directory '{f0_subdir}' does not exist, will use pyin extraction")
            
            # Build output path
            output_subdir = os.path.join(output_dir, rel_dir)
            os.makedirs(output_subdir, exist_ok=True)
            output_path = os.path.join(output_subdir, f"{base_name}.npz")
            
            print(f"\nProcessing: {rel_path}")
            
            try:
                # Call build_single_npz function to process single file
                build_single_npz(
                    wav_path=wav_path,
                    textgrid_path=tg_path,
                    output_path=output_path,
                    use_external_f0=use_external_f0,
                    f0_dir=current_f0_dir
                )
                processed_files += 1
            except Exception as e:
                print(f"❌ Error processing {rel_path}: {e}")
                skipped_files += 1
    
    print(f"\n✅ Batch processing completed!")
    print(f"Total files: {total_files}")
    print(f"Successfully processed: {processed_files}")
    print(f"Skipped/failed: {skipped_files}")
    print(f"Output directory: {output_dir}")
    
    return processed_files

def main_batch():
    """
    Main function for batch processing.
    """
    parser = argparse.ArgumentParser(description="Batch build DiffSinger .npz dataset with external F0 support.")
    parser.add_argument("--wav_dir", required=True, help="Directory containing dry vocal WAV files")
    parser.add_argument("--textgrid_dir", required=True, help="Directory containing TextGrid files")
    parser.add_argument("--f0_dir", help="Directory containing external F0 files (optional, expects {basename}.f0.npy)")
    parser.add_argument("--output_dir", required=True, help="Output directory for .npz files")
    parser.add_argument("--use_external_f0", action="store_true",
                        help="Enable loading of external F0 (first checks --f0_dir if provided, then wav directory)")
    parser.add_argument("--speaker_id", type=int, default=0, help="Speaker ID (default: 0)")
    args = parser.parse_args()
    
    # Process directory
    process_directory(
        wav_dir=args.wav_dir,
        textgrid_dir=args.textgrid_dir,
        output_dir=args.output_dir,
        f0_dir=args.f0_dir,
        use_external_f0=args.use_external_f0,
        speaker_id=args.speaker_id
    )

if __name__ == "__main__":
    main_batch()
